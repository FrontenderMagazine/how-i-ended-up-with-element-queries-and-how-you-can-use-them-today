# Поиски святого Грааля: Как я пришёл к выражениям для элементов и как пользоваться ими уже сегодня

Какое-то время я испытывал трудности с тем, **на что способен CSS**. Тот, кто
разрабатывает адаптивные веб-дизайны, охотно признает, что в CSS есть
разочаровывающие недостатки, которые заставляют применять препроцессоры, плагины
и прочие утилиты для написания тех стилей, которые при помощи одного только CSS
написать невозможно. Но даже эти утилиты имеют свои ограничения в том, чем они
могут нам помочь.

Представьте на мгновение строительство здания. Если вы строите большое сооружение
из непрочного материала, то потребуется много внешних стяжек и подпорок, чтобы
оно могло устоять. При строительстве сайта из HTML, CSS и JavaScript в качестве
таких стяжек могут выступать фреймворки, плагины, препроцессоры, транспилеры,
редакторы, пакетные менеджеры и процессы сборки.

Вместо того, чтобы добавить очередной плагин в довесок к имеющимся, я задумался:
а может, **расширив один из основных языков, CSS**, мы могли бы усилить тот
материал, из которого строятся сайты, и разрабатывать более хорошие, прочные
сайты, требующие меньше стяжек и инструментов для постройки.

## Текущее положение дел

При использовании утилит вроде препроцессоров мы пишем CSS в кратком виде, а
затем он разворачивается в своё полное представление (перед тем, как он будет
использован в браузере). Плагины на странице могут взаимодействовать с элементами
на одном уровне, но чтобы применить стили, им приходится или писать стили CSS
прямо в HTML, или манипулировать именами классов, которым соответствуют разные
правила CSS. В обоих случаях нам приходится писать или генерировать нужный нам
CSS перед тем, как страница загрузится.

### Проблема

Проблема такого подхода в том, что даже самые лучшие плагины часто **требуют
настройки и конфигурации** под каждый используемый вами макет. К тому же,
если JavaScript пишет стили за вас, при рефакторинге или переиспользовании кода
может быть трудно следить за тем, чтобы логика плагина работала правильно с
вашими стилями CSS.

Другая проблема с препроцессорами состоит в том, что любая ошибка в краткой
записи быстро разбухает в огромное месиво после преобразования CSS в полную
форму. При использовании плагинов мы добавляем много потенциальных точек отказа.
Может быть, мы используем множество плагинов, чтобы достичь тех немногих целей,
которые, возможно, были бы и не нужны, будь CSS немного мощнее. Это создаёт
лишние накладные расходы, которые разработчикам сложнее поддерживать, браузерам
отрисовывать, а пользователям загружать.

### Есть ли надежды на будущее веб-разработки?

В 2013 Тайсон Матанич (Tyson Matanich) написал статью, озаглавленную
[«Медиавыражения не решение: Полифилл выражений для элементов»][media-queries-are-not-the-answer], в которой
представил широкой публике концепцию выражений для элементов (element queries).
С неё началось обсуждение того, как можно было бы обойти недостатки CSS при
помощи плагинов и полифиллов.

С тех пор, пока мы ждём улучшения возможностей CSS, появился ряд плагинов,
позволяющих разработчикам использовать выражения для элементов несколькими
различными способами.

### Что такое выражения для элементов?

Выражения для элементов похожи на медиавыражения, с тем отличием, что правила
зависят от свойств конкретного элемента, а не порта просмотра браузера.

## Как появился EQCSS

В конце 2013 мне довелось работать над фронтендом веб-приложения на Ruby on
Rails. Приложение должно было отображать пользователям подробную информацию, и
целью стала разработка адаптивного интерфейса, который бы одинаково подходил и
для телефонов, и для планшетов, и для десктопов. Это вызвало ряд затруднений,
оно из которых было в том, что большую часть важной информации предполагалось
отображать в виде таблиц — да, самых настоящих элементов `table` (финансовые
транзакции, спортивные рекорды и т.п.).

![][eqcss-logo]

_Проект EQCSS появился как результат исследования выражений для элементов.
Теперь, когда он [наконец выпущен][eqcss-gh], вы тоже можете им воспользоваться.
[Посмотреть демо.][eqcss-demos]_

Я написал адаптивные стили с использованием медиавыражений, которые отображали
элемент `table` правильно для браузеров различных размеров. Но как только одна
из таких таблиц оказывалась в шаблоне, содержащем боковую панель, внезапно
все контрольные точки моих медиавыражений становились *бесконтрольными*. Они
попросту не учитывали двухсотпиксельную боковую панель, элементы наползали друг
на друга и всё выглядело сломанным.

Другое препятствие: имена пользователей могли содержать от 3 до 20 букв, и я
осознал, что хочу. чтобы **размер шрифта имени пользователя изменялся в
зависимости от числа символов** в нём. Мне нужно было располагать все имена
пользователей в боковой панели, и было нелегко подобрать такой размер шрифта,
чтобы имена из 20 букв вместились, а трёхбуквенные хорошо читались.

Чтобы решить проблемы наподобие этих, я часто копировал медиавыражения целиком,
дублировал большие куски кода, просто из-за того, что мне не хватало более
разумного способа применения адаптивных стили к каждому макету. Я также
полагался на JavaScript, но такое решение тоже не было красивым, я писал почти
идентичные функции, каждую для своей страницы, применяющие стили к тем местам,
с которыми CSS не справлялся. Позже кодовая база распухла от всего этого
копипаста, и вносить изменения в код стало затруднительно.

Я знал, должно же быть решение получше. И через какое-то время я начал думать,
что мне не нужны медиавыражения, то, что мне нужно — это выражения для элементов!

### Исследование и разработка

С начала 2014 я начал экспериментировать с различными способами сообщить CSS о
свойствах отображаемого на странице элемента, это помогло бы улучшить мои стили.
Я надеялся найти подход к написанию стилей, сочетающий красоту CSS и мощь
JavaScript.

Вот некоторые из неудачных экспериментов: добавление атрибутов тегам HTML в
в надежде получить поддержку адаптивности и попытки найти способ внедрять целые
блоки CSS внутрь конструкций `if` в JavaScript, чтобы создать этакого монстра
Франкенштейна, сшитого нитками из JavaScript и CSS.

Но вместо того, чтобы облегчать задачу, все мои неудачные попытки имели кое-что
общее: они добавляли ещё больше работы! Я знал, что правильное решение должно
упрощать и облегчать работу, так что я продолжал поиски. После всех
экспериментов у меня выработалось чёткое представление о том, как должен
выглядеть синтаксис, при котором выражения для элементов будут работать хорошо.

Как я говорил выше, у сайта, построенного из HTML, CSS и JavaScript, роль стяжек
выполняют фреймворки, плагины, препроцессоры, транспилеры, редакторы, пакетные
менеджеры и процессы сборки. Вместо того, чтобы добавить очередной плагин в
довесок к имеющимся, я задумался: а может, расширив один из основных языков,
CSS, мы могли бы усилить тот материал, из которого строятся сайты, и
разрабатывать более хорошие, прочные сайты, требующие меньше стяжек и
инструментов для постройки.

### Рождение синтаксиса

Имея лучшее представление о том, какой синтаксис мне требуется, в концу 2014
я обратился к Максиму Узье (Maxime Euzière), феноменальному JavaScript
код-гольферу, и спросил его, возможно ли расширять CSS на уже загруженной
странице при помощи браузерного JavaScript. Он не только сообщил мне, что это
возможно, но и предложил свою помощь в реализации! Мы назвали синтаксис EQCSS,
как сокращение от «element query CSS». Также название намекает на слово
«excess» (англ. «избыток»), потому что он делает то, что превышает возможности
CSS.

### Потребность

Моё требование к синтаксису было таковым: он должен быть максимально **похожим
на CSS**. Настолько похожим, что даже подсветка синтаксиса не должна замечать
подвоха и считать, что это обычный CSS. Так я наметил синтаксис выражений
для элементов, настолько логичный, что люди удивляются, как же так вышло, что
его ещё не существует.

Я знал, что если мы собираемся расширять браузерную поддержку CSS используя
JavaScript, то плагин должен быть настолько легковесным и простым, насколько
это возможно. Так что вариант оформить это в виде плагина библиотеки вроде
jQuery вычеркнули из списка. Мне нужна была библиотека на чистом JavaScript,
которая добавляла бы требуемые возможности из будущего в те браузеры, которые
мне нужно поддерживать сейчас.

На текущий момент сообщество CSS сосредоточено на обсуждении нестандартных
директив, и обсуждение выражений для элементов
[до сих пор несёт предварительный характер][wicg]. Скорее всего, нас отделяют годы от
какой-либо официальной спецификации CSS по возможностям вроде этой. Да и будь
у нас спецификация, перед тем, как использовать эти возможности при разработке
сайтов, нам всё равно бы пришлось ждать, пока достаточное количество браузеров
реализует её.

Нет смысла ждать, пока эти возможности попадут в CSS, если нам нужна эта
функциональность, чтобы создавать и поддерживать сайты уже сейчас.

### Результат

Результатом этого исследования стало создание синтаксиса, включающего в себя
ряд новых продвинутых условий для адаптивности, стилей с изолированной областью
применения и новых селекторов для выборки элементов, а также библиотеку на
чистом JavaScript под названием [EQCSS.js][eqcss-gh]. Плюс, поддержка Internet
Explorer (IE) 8 осуществляется при помощи необязательного внешнего полифилла.
И плагин и полифилл выпущены под [лицензией MIT][mit-license], их использование бесплатно
для всех.

## Где полезны выражения для элементов

### Разработка плагинов

При создании интерфейсных компонентов и виджетов разработчики часто оказываются
ограниченными медиавыражениями. Нам часто приходится делать выбор между тем,
чтобы создавать множество различных лейаутов, настраиваемых при помощи плагина, и
тем, чтобы сделать интерфейс как можно проще, так что одно решение будет
работать в большинстве ситуаций.

Однако, при разработке плагинов и интерфейсов с выражениями для элементов мы
с лёгкостью можем писать адаптивные стили для любой нужной нам ситуации.
Получается безотказное решение, неважно, какое содержимое пользователь решит
поместить в блок, или где плагин находится. Если мы зададим стили виджета для
всех ширин от 150 до 2000 пикселей, то куда его на сайте ни помести, он везде
будет выглядеть отлично.

### Компоненты шаблона

На этапе прототипа сайта часто происходит реорганизация элементов дизайна, а
сам дизайн представляется как набор модульных компонентов. Если вы на этом этапе
написали медиавыражение, иногда может оказаться, что это **преждевременная
оптимизация**. Разрабатывая с использованием выражений для элементов, вы
оставляете условия адаптивности независимыми от макета, что даёт вам больше
гибкости и возможность перемещать элементы без необходимости сильно переписывать
стили.

Мне кажется наиболее полезным использование выражений для элементов при
разработке дизайна или набросков таких вещей как:

*   меню навигации;
*   модальные диалоги;
*   формы регистрации и авторизации;
*   подвалы;
*   блоки расценок;
*   лендинги;
*   таблицы;
*   кнопки вкладок;
*   аккордеоны;
*   боковые панели;
*   медиапроигрыватели;
*   блоки отзывов.

Любой элемент дизайна можно изолировать и переместить куда угодно — с одной
страницы на другую, или с одного сайта на другой.

### Поддержка устройств

Одна из проблем, с которыми вы сталкиваетесь при поддержке мобильного веба — это
разнообразие устройств. Рынок устройств сегодня более фрагментирован, чем
когда-либо, и новые планшеты и телефоны появляются каждый день. Мы уже не в
состоянии поддерживать список поддерживаемых браузеров и устройств, так что
исключительно важно знать наверняка, что дизайн работает везде, даже на ещё не
выпущенных устройствах.

Используя выражения для элементов, вы можете разрабатывать сайты лучше и
избавиться от различий между браузерами.

Есть большое количество недавних статей про необходимость выражений для
элементов, и в них есть множество примеров их применения в деталях. Так давайте
же разберёмся, как их использовать!

## Как писать выражения для элементов

Начать работать с EQCSS легко. Всё, что вам нужно для того, чтобы использовать
синтаксис EQCSS,— это [подключить скрипт][eqcss] где-либо в HTML.

### Загрузка EQCSS.js

Если вы хотите склонировать проект EQCSS GitHub, вы можете набрать:

    git clone https://github.com/eqcss/eqcss.git

Если вы используете npm, вы можете добавить EQCSS в проект следующей командой:

    npm install eqcss

### Добавление EQCSS.js в HTML

После того, как вы загрузите EQCSS, вы можете подключить его в HTML используя
тег `script`:

    <script src="EQCSS.js"></script>

Этот файл (`EQCSS.js`) включает в себя поддержку всех современных браузеров,
включая IE9 и выше. Для поддержки IE8 нам пришлось бы использовать кучу других
полифиллов. Задумайтесь, в IE 8 даже медиавыражения без полифиллов не
поддерживаются, поэтому достаточно удивительно, что нам удалось заставить там
работать выражения для элементов. Чтобы добавить EQCSS поддержку IE8, добавьте
следующую строчку перед местом подключения основного плагина:

    <!‐‐[if lt IE 9]><script src="EQCSS‐polyfills.js"></script><![endif]‐‐>

### Запуск EQCSS

По умолчанию плагин EQCSS рассчитывает все стили, которые он найдёт в документе,
в момент загрузки страницы и когда обнаружит изменение размеров окна,
поведение похожее на медиавыражения. Также можно вручную вызвать `EQCSS.apply()`
из JavaScript, чтобы пересчитать стили в любой момент, это может быть полезно,
если содержимое страницы меняется.

### Написание Element Query CSS

Плагин EQCSS.js может читать стили несколькими различными способами. Вы можете
вставить EQCSS в любой тег `style` на странице. Также можно писать EQCSS во
внешних файлах стилей.

Если вам хочется хранить код для EQCSS отдельно от CSS, вы можете загрузить
стили EQCSS используя тег `script` с атрибутом `type` равным `text/eqcss`.
При использовании такого способа стили можно записать внутри тега, или указать
ссылку на внешний файл `.eqcss`:
`<script type="text/eqcss" src=styles.eqcss></script>` подгрузит файл с именем
`styles.eqcss`.

## Анатомия выражений для элементов

### Области применения стилей

Синтаксис EQCSS для написания выражений для элементов очень похож внешне на
медиавыражения, но вместо `@media` мы начинаем выражение с `@element`.
Единственная дополнительная информация, которую нужно указать — это минимум один
селектор, к которому эти стили будут применяться. Например, вот так задаётся
область применения для элемента `<div class="widget">`:

    @element '.widget' {
    
    }

Часть кода между кавычками (в нашем случае `.widget`) может быть любым валидным
селектором CSS. Этим выражением мы создали новую область применения для элемента
`.widget`. Но мы пока что не указали ни одного условия адаптивности для этой
области, так что стили внутри неё будут применяться к элементу всегда.

Без возможности изолировать стили, привязывая их к одному или нескольким
элементам (вместо страницы целиком), у нас не получилось бы применять
условия адаптивности только к этим элементам. Но как только мы создаём область
видимости, становится легко использовать продвинутые возможности EQCSS,
например, мета-селектор `$parent`, потому что у JavaScript теперь есть опорная
точка, от которой можно рассчитывать вещи вроде `parentNode` элемента. Это
важно!

Да, в CSS уже есть селектор прямого потока, с комбинатором `>`, который
позволяет выбирать дочерние элементы указанного элемента. Но CSS пока не
предоставляет никаких возможностей путешествовать вверх по семейному древу и
выбирать родителей, то есть, элементы, содержащие данный элемент. В спецификации
CSS 4 появился [селектор `:has()`][css-has], принципиально похожий на
[селектор `:has()`][jquery-has] в jQuery, но на сегодняшний день
[поддержка браузерами нулевая][caniuse-has]. С областями применения мы можем обращаться
к родительским элементам по-другому.

Теперь, когда мы объявили область применения в контексте элемента `.widget`,
мы можем использовать его как точку отсчёта и обращаться к родителю:

    @element '.widget' {
      $parent {
        /* Эти стили применятся к родителю .widget */
      }
    }

Другой пример специальных селекторов, использующихся в выражениях для
элементов,— селекторы `$prev` и `$next`, они представляют предыдущий и следующий
соседние элементы соответственно. Опять-таки, в CSS можно добраться до
следующего соседа нашего виджета при помощи селектора вроде `.widget + *`, но
нет возможности пойти назад и получить элемент, который идёт непосредственно
перед другим элементом.

    <section>
      <div>Это предыдущий элемент</div>
      <div class="widget">Это элемент области определения</div>
      <div>Это следующий элемент</div>
    </section>
    <style>
      @element '.widget' {
        $prev {
          /* Эти стили применятся к элементу перед .widget */
        }
        $next {
          /* Эти стили применятся к элементу после .widget */
        }
      }
    </style>

### Выражения для элементов

Чаще всего разработчики использую медиавыражения для адаптивного дизайна,
применяя стили на основе высоты или ширины порта просмотра браузера. Синтаксис
EQCSS поддерживает новые типы адаптивных условий. Вместо того, чтобы работать
только с шириной и высотой браузера, вы можете написать стили, которые
применяются к элементу на основе его собственных свойств. Таких, например, как
количество дочерних элементов или количество символов или строк текста на
текущий момент.

Добавление этих условий в область определения стиля похоже на то, как вы пишете
медиавыражения: нужно добавить `and (условие: значение)` для каждого нужного
условия. В этом примере мы проверяем, есть ли на странице элементы `.widget`
шириной минимум 500 пикселей.

    @element '.widget' and (min‐width: 500px) {
      /* Тут правила CSS */
    }

Подробно синтаксис выражений для элементов таков:

*   **выражение для элемента**

    `@element список_селекторов [ список_условий ] { код_css }`

*   **список селекторов**

    `" селектор css [ "," селектор css ]* "`

*   **список условий**

    `and ( условие_выражения : значение ) [ "and (" условие_выражения ":" значение ")" ]*`

*   **значение**

    `число [ единица измерения css ]`

*   **условие выражения**

    `min-height | max-height | min-width | max-width | min-characters | max-characters | min-lines | max-lines | min-children | max-children | min-scroll-y | max-scroll-y | min-scroll-x | max-scroll-x`

*   **единица измерения css**

    `% | px | pt | em | cm | mm | rem | ex | ch | pc | vw | vh | vmin | vmax`

Вот другой пример, как написать выражение, при котором элемент `body` становится
красным, если ширина элемента `.widget` достигает 500 пикселей:

    @element '.widget' and (min‐width: 500px) {
      body {
        background: red;
      }
    }

Заметьте, что элемент `body` изменяется, когда `.widget` достигает определённой
ширины, но сам элемент `.widget` не меняется!

## Условия выражений для элементов

Ниже приведён полный список условий адаптивности, поддерживаемый EQCSS.

### Условия на основе ширины

*   `min-width`

    [демо для пикселей][MeKwaY], [демо для процентов][ezJNpp]

*   `max-width`

    [демо для пикселей][EyPjVg], [демо для процентов][oLbXzG]

### Условия на основе высоты

*   `min-height`

    [демо для пикселей][PzZqPd], [демо для процентов][KMVpdO]

*   `max-height`

    [демо для пикселей][EyPjPg], [демо для процентов][xOZGZg]

### Условия на основе количества

*   `min-characters`

    [демо для блочных элементов][vKLOLd], [демо для элементов формы][OXMVMB]

*   `max-characters`

    [демо для блочных элементов][pbgJyz], [демо для элементов формы][MeKwyY]

*   `min-lines`

    [демо][JKGdXN]

*   `max-lines`

    [демо][oLbXxG]

*   `min-children`

    [демо][dXGoMZ]

*   `max-children`

    [демо][mEVJPK]


### Условия на основе прокрутки

*   `min-scroll-y`

    [демо][OXMVNa]
*   `max-scroll-y`

    [демо][beEdpZ]

*   `min-scroll-x`

    [демо][ZOQGOb]

*   `max-scroll-x`

    [демо][ezJNzJ]

Вы можете сочетать любое количество этих условий в выражении для элемента и
получить по-настоящему многомерные адаптивные стили. Это предоставляет больше
гибкости и контроля над тем, как элементы выглядят. К примеру, чтобы уменьшить
размер шрифта заголовка, в котором содержится более 15 символов, и если меньше
600 пикселей по ширине доступно для отображения, вы можете применить совместно
условия `max-characters: 15` и `max-width: 600px`:

    h1 {
      font‐size: 24pt;
    }
    @element 'h1' and (min‐characters: 16) and (max‐width: 600px) {
      h1 {
        font‐size: 20pt;
      }
    }

### Мета-селекторы

Одна из проблем, с которыми вы можете столкнуться при использовании стилей с
областями определения и адаптивными условиями: если на странице есть несколько
элементов с одинаковым селектором, то использование этого селектора в выражении
для элемента приведёт к тому, что стили будут применены *ко всем* элементам
на странице, подпадающих под этот селектор, если *хотя бы один* из них
соответствует условию. Вернёмся к нашему примеру с `.widget` и предположим, что
на странице есть два виджета (например, один в боковой панели, а другой
отображается на всю ширину), а мы написали выражение для элемента таким образом:

    @element '.widget' and (min‐width: 500px) {
      .widget h2 {
        font‐size: 14pt;
      }
    }

Это будет значить, что когда *любой из* элементов `.widget` на странице шириной
минимум 500 пикселей, то стиль применится к обоим элементам `.widget`. В большей
части случаев, пожалуй. это не то, что нам нужно. Но в этой ситуации нам помогут
мета-селекторы!

Выражение для элемента состоит из двух частей: селектора и условия. И если мы
хотим применять стили только к тем элементам на страницы, которые соответствуют
*и* селектору *и* условию одновременно, то можно использовать мета-селектор
`$this`. Давайте перепишем наш последний пример так, чтобы стили применялись
только к элементам `.widget`, соответствующим условию `min‐width: 500px`:

    @element '.widget' and (min‐width: 500px) {
      $this h2 {
        font‐size: 14pt;
      }
    }

В синтаксисе EQCSS поддерживается ряд селекторов, которых нет в обычном CSS.
Вот их полный список:
the full list:

*   `$this`

    [демо][xOZGOq]

*   `$parent`

    [демо][VjeLjy]

*   `$root`

    [демо][RRrPRy]

*   `$prev`

    [демо][gMPpMd]

*   `$next`

    [демо][PzZqzy]

Эти селекторы работают только внутри выражений для элементов.

### Открываем портал между JavaScript и CSS

*   `eval('')`

    [демо][WxrvxB]

Последняя возможность EQCSS самая крутая из всех — `eval('')`. Благодаря ней
вся мощь JavaScript становится доступной из CSS. Хотя JavaScript и может
применять стили к элементам, но к некоторым местам ему пробраться трудно,
например к псевдоэлементам `:before` и `:after`. Но что, если CSS смог бы
добраться до JavaScript с другой стороны? Что если JavaScript не задавал бы
никаких свойств CSS, а напротив, CSS знал бы о существовании JavaScript?

В этом нам поможет `eval('')`. Вы можете выполнять любой JavaScript, можно
обратиться к переменной JavaScript в CSS; запустить однострочник на
JavaScript (вроде `eval('new Date().getFullYear()')`); или считать какие-либо
значения, связанные с браузером и другими элементами, к которым JavaScript имеет
доступ (например, `eval('innerHeight')`); или можно запустить функцию и
использовать в CSS её результат. Вот пример, который выводит `© 2016` в элементе
`<footer>`:

    @element 'footer' {
      $this:after {
        content: "© eval('new Date().getFullYear()')";
      }
    }

При выполнении JavaScript, `eval('')` работает в контексте выбранного элемента,
того самого, к которому применяются стили `$this`. Вы можете использовать
в скрипте внутри `eval('')` переменную  `$it` в качестве ссылки на элемент, если
вам хочется упорядочить код. Но даже если вы не станете её использовать, всё
будет работать точно так же. Для примера предположим, что у нас есть `div`,
содержащий слово «привет». Следующий код выведет «привет привет»:

    <div>привет</div>
    <style>
      @element 'div' {
        div:before {
          content: "eval('$it.textContent') ";
        }
      }
    </style>

Здесь `$it` ссылается на `div`, потому что это селектор текущей области
определения. Можно даже не писать `$it`, следующий код будет делать то же
самое:

    @element 'div' {
      div:before {
        content: "eval('textContent') ";
      }
    }

`eval('')` может быть полезен в ситуациях, когда CSS ничего не знает об
измерениях или событиях, произошедших на странице с момента загрузки. К примеру,
элементы iframe, использующиеся при вставке видео с YouTube, идут с определённой
шириной и высотой. Хотя вы и можете установить `width: auto` в CSS, поддерживать
правильное соотношение сторон проблематично, если видео занимает всё доступное
место.

Часто эта проблема при адаптивной вёрстке решается так: содержимое, соотношения
сторон которого нужно сохранить, помещается в обёртку, а обёртке задаётся
отбивка, значение которой рассчитано исходя из нужного соотношения сторон. Это
работает, но нужно знать соотношения сторон всех видео заранее, да ещё и нужно
писать больше кода HTML (обёртку) для каждого вставленного видео. И весь этот
шлак был бы не нужен, будь CSS чуточку поумнее.

Может быть, более разумным подходом было бы завернуть видео в обёртки без
отбивки, а затем написать библиотеку на JavaScript, которая считала бы
соотношения сторон каждого видео, а затем применяла бы нужно количество отбивки
каждой обёртке.

Но что, если бы CSS *мог* иметь доступ к этим измерениям напрямую? Мы смогли бы
не только объединить весь CSS для всех соотношений сторон в одно правило, но
к тому же, если бы это правило вычислялось по загрузке страницы, могли бы
написать одно правило для всех видео, которые у нас когда-либо появятся.
И нам даже не пришлось бы использовать обёртки!

Если это звучит слишком хорошо, чтобы быть правдой, то зацените. Вот, как
просто написать адаптивное изменение размеров iframe без обёрток в EQCSS:

    @element 'iframe' {
      $this {
        margin: 0 auto;
        width: 100%;
        height: eval('clientWidth/(width/height)');
      }
    }

Здесь `width` и `height` — это атрибуты `width=""` и `height=""` элемента
`iframe` в HTML. JavaScript вычисляет `(width/height)`, что даёт нам соотношение
сторон. И чтобы применить его к любой ширине, мы просто делим текущую ширину
элемента на это соотношение.

Краткость и читаемость CSS и вся мощь JavaScript. Никаких лишних обёрток,
никаких лишних классов, никакого лишнего CSS.

Но будьте осторожны с `eval('')`. [Неспроста][ending-expressions] CSS-выражения (CSS
expressions) раньше считались опасными, и также неспроста мы тщательно
исследовали эту идею. Если вы не будете следить за тем, к какому количеству
элементов на странице они применяются, и за тем, как часто вы пересчитываете
стили, это может закончится тем, что JavaScript придётся делать в сотни раз
больше работы, чем это требуется. К счастью, EQCSS позволяет вызывать
`EQCSS.apply()` или `EQCSS.throttle()`, чтобы пересчитать стили вручную, и у нас
больше контроля над тем, когда стили обновляются.

### Опасная зона!

Другие неприятности могут произойти, если вы создаёте выражения с конфликтующими
условиями или стилями. EQCSS, как и CSS, читается сверху вниз с учётом
[иерархии специфичности][css-specificity]. Хотя CSS и декларативный язык, в нём есть и
продвинутые возможности. В качестве языка программирования он всего лишь в паре
шагов от полноты по Тьюрингу. До сих пор отладка CSS была достаточно
бесхитростным занятием, но EQCSS превращает CSS из простого интерпретируемого
языка в **динамический язык стилей** с дополнительным слоем интерпретации между
CSS и браузером. На новой территории нас, возможно, ожидают и новые западни.

Вот пример двустороннего зацикливания в EQCSS, того, чем обычные медиавыражения
в CSS не могут страдать в принципе:

    @element '.widget' and (min‐width: 300px) {
      $this {
        width: 200px;
      }
    }

Я называю это `jekyll: hide;` CSS. Но в дополнение к тому, что один стиль может
постоянно вызывать себя, есть ещё и возможность того, что несколько выражений
будут вызывать друг друга, находясь в состоянии, которое мы называем
«дважды инвертированным двусторонним зацикливанием», самым мерзким из всех:

    @element '.widget' and (min‐width: 400px) {
      $this {
        width: 200px;
      }
    }
    @element '.widget' and (max‐width: 300px) {
      $this {
        width: 500px;
      }
    }

В теории, этот несчастный виджет не сможет определиться с шириной и застрянет в
цикле, меняя ширину с 200 на 500 пикселей и обратно до скончания времён. В
случаях наподобие этого EQCSS просто рассчитывает правила в том порядке, в каком
они выполняются, награждает победителя и идёт дальше. Если у правил одинаковая
специфичность, и вы поменяете их порядок, последний стиль будет всегда
побеждать.

Некоторые говорят, что возможность создавать зацикливания (или даже дважды
инвертированные двусторонние зацикливания) означает недоработку при
проектировании, но чтобы избежать зацикливаний, нам пришлось бы ограничить
возможности EQCSS настолько, что пропала бы большая часть пользы от синтаксиса.
С другой стороны, создать бесконечный цикл в JavaScript проще простого, но
об этом не говорят, как об ошибке проектирования — наоборот, об этом говорят
как о доказательстве его больших возможностей! С выражениями для элементов то же
самое.

### Отладка выражений для элементов

На текущий момент отладка выражений для элементов по ощущениям немного похожа на
отладку медиавыражений во времена, когда у нас ещё не было утилит вроде
веб-инспектора, показывающих, рассчитанные стили. Сейчас отладка и разработка
выражений для элементов требует от разработчика держать в голове представление
о том, как адаптивность себя ведёт. В будущем возможно появятся инструменты
отладки, принимающие во внимание EQCSS, но сейчас в отладчиках показываются
только те стили, которые были применены к элементам на странице, и об условиях
адаптивности EQCSS они понятия не имеют.

## Как разрабатывать с выражениями для элементов

Самый просто способ начать пользоваться выражениями для элементов — это
перевести существующие стили с использования медиавыражений на выражения для
элементов, «освобождая» элементы и их адаптивные стили от привязки к одному
лейауту и упрощая тем самым их повторное использование на других страницах и в
других проектах. Следующие медиавыражения и выражения для элементов могут
значить одно и то же:

    footer a {
      display: inline-block;
    }
    
    @media (max‐width: 500px) {
      footer a {
        display: block;
      }
    }

    footer a {
      display: inline-block;
    }
    
    @element 'footer' and (max‐width: 500px) {
      $this a {
        display: block;
      }
    }

Разница в том, что в первом примере ссылки в подвале всегда остаются
`display: block`, пока *браузер* шириной хотя бы 500 пикселей. Второй пример, с
использованием  выражений для элементов, будет выглядеть так же, но только если
сам элемент `footer` расположен во всю ширину.

После освобождения этого стиля от его изначального медиавыражения, мы теперь можем
размещать подвал в контейнере любой ширины и быть уверенными, что когда к
подвалу потребуется применить стили (т.е., когда он уже, чем 500 пикселей), они
применятся.

1.  Убедитесь, что `EQCSS.js` существует в коде HTML документа.
2.  Замените `@media` на `@element` в CSS.
3.  Добавьте селектор CSS в область определения каждого выражения `@element`.
4.  Опционально: Замените в выражениях для элементов вхождения самого элемента
    на `$this`.

Если компонент не был изначально рассчитан на отображение на всю ширину порта
просмотра браузера, после перевода его на выражения для элементов скорее всего
придётся подредактировать ключевые точки.

## Готовность к переменам

Писать на EQCSS — это примерно то же самое, что писать на обычном CSS: все ваши
любимые свойства и приёмы CSS остались теми же, просто добавились новые
возможности, позволяющие им по-новому работать вместе. Из-за того, что EQCSS
отдаёт браузеру стандартный CSS, любая особенность CSS, которую умеет ваш
браузер, будет также работать и с EQCSS. Если когда-нибудь возможности вроде
выражений для элементов или областей определения стилей появятся в стандарте
CSS, и браузер начнёт их поддерживать, то вы сразу сможете использовать эти
возможности в коде EQCSS, при этом всё ещё полагаясь на EQCSS в тех вещах,
которые браузер ещё не поддерживает нативно.

Благодаря тому, что синтаксис EQCSS можно использовать как прямо из CSS, так и
через подключенный скрипт с типом `text/eqcss`, если в CSS когда-нибудь появится
нативный синтаксис выражений для элементов, вы всё равно сможете загружать EQCSS
как скрипт и избежать конфликтов.

Заглядывая в будущее, есть одно решение, с которым разработчики браузеров сейчас
экспериментируют, [Houdini][houdini], оно дало бы разработчикам плагинов возможность
расширять CSS по-новому, сродни добавлению поддержки в сам браузер. Возможно,
когда-нибудь мы сможем писать более эффективные плагины, интерпретирующие EQCSS,
и привносящие эти возможности в браузер более прямым и быстрым способом, чем
сейчас это позволяет библиотека на JavaScript.

## Так следует ли продолжать пользоваться медиавыражениями?

Да, хотя выражения для элементов и приносят много новых и восхитительных
возможностей применения стилей к элементам, медиавыражения (несмотря на свою
ограниченность) всегда будут работать в браузере быстрее, чем стили,
полагающиеся на JavaScript. Однако, медиавыражения CSS — это нечто большее,
чем просто внешний вид HTML на экране. Медиавыражения также включают выражения
для печатных версий и других способов отображения информации сайтом. EQCSS может
быть использован совместно с медиавыражениями для вещей вроде стилей для
печати, так что не стоит выбрасывать медиавыражения на свалку только из-за
того, что теперь появились ещё и выражения для элементов!

### Взгляд в ближайшее будущее

Лучшее, что вы можете сделать для будущего CSS — как можно больше
экспериментировать с этими идеями сегодня. Даже сотни часов мозговых штурмов
и теоретических изысканий насчёт этих возможностей не заменят попыток
реализовать и применить их на практике, открывая новые техники, делающие их
полезными и мощными.

Вдобавок к тому, что EQCSS.js добавляет поддержку выражений для элементов, он,
надеюсь, послужит ещё и основой для экспериментов по дальнейшему расширению CSS.
Если вы хотите добавить в код новое условие адаптивности, свойство CSS или
селектор, форкните EQCSS.js и модифицируйте его, добавив свою идею, и большая
часть дела сделана, с минимальными усилиями.

## Модульный дизайн

При разработке макета с выражениями для элементов происходит смена парадигмы.
Мы перестаём смотреть на DOM сверху вниз только с точки зрения корневого
элемента HTML, и начинаем рассматривать каждый отдельный элемент страницы с
перспективы самого элемента и его расположения в документе.

Старые подходы к адаптивности «сначала декстоп» и «сначала мобильные» уже не
актуальны, новый способ разработки макетов близок к подходу «сначала элемент».
Использование выражений для элементов позволяется работать с обособленными
и изолированными друг от друга составными частями макета и определять их стиль
более подробно. Если вы уже используете модульный подход на бэкенде и хотели
бы так же обособлять CSS в модули, но у вас не получалось сделать это из-за
ограниченных возможностей медиавыражений, то выражения для элементов — как раз,
то, что наконец позволит вам применять подобный модульный подход к стилям.

## Думаем сначала об элементе

Подход «сначала элемент» схож по духу с [принципом атомарного дизайна][atomic-web-design], но
на практике отличается внешне от того, как большая часть людей реализовала
атомарные дизайны в прошлом.

Для примера предположим, что у нас есть HTML вроде приведённого ниже, и желаемый
адаптивный эффект такой: «Поле ввода поиска и кнопка располагаются рядом друг
с другом пока форма не станет слишком узкой. Если это случится, и поле ввода
и кнопка должны выстроиться в колонку, одно над другим, и отображаться на всю
ширину.»

    <form>
      <input type=search>
      <input type=button value=Поиск>
    </form>

### Подход «сначала десктоп»

В случае, если вы заботитесь в первую очередь о десктопе, вы пишете сначала
стили для десктопа, а затем добавляете поддержку адаптивности для экранов
меньшего размера.

    input {
      width: 50%;
      float: left;
    }
    @media (max‐width: 600px) {
      input {
        width: 100%;
        float: none;
      }
    }

### Подход «сначала мобильные»

С таким подходом вы сначала разрабатываете мобильную версию, а затем добавляете
поддержку отображения в одну строку только когда экран достаточно большой.

    input {
      width: 100%;
    }
    @media (min‐width: 600px) {
      input {
        width: 50%;
        float: left;
      }
    }

### Подход «сначала элемент»

В двух предыдущих примерах контрольная точка была выставлена на 600 пикселей, и
это не потому что такой ширины будут поле ввода и кнопка, когда они поменяют
вид. Весьма вероятно, что поле ввода находится внутри хотя бы одного
родительского элемента, а у того могут быть отступы или отбивка. Так что, когда
браузер будет 600 пикселей шириной, ширина этих контролов будет где-то 525—550
пикселей. И в подходе «сначала десктоп», и в подходе «сначала мобильные» вы
всегда выставляете контрольные точки с учётом разметки и того, как элементы в
ней расположены. С подходом «сначала элемент» вы говорите: «Мне неважно, какой
ширины браузер. Я знаю, что элементы должны выстраиваться в колонку, когда они
определённой ширины, и примерно 530 пикселей — самое то.» Вместо использования
медиавыражения для переключения CSS на основе размеров браузера, при подходе
«сначала элемент» мы привязываем адаптивные стили к самому элементу `form` и
пишем так:

    input {
      width: 100%
    }
    @element 'form' and (min‐width: 530px) {
      $this input {
        width: 50%;
        float: left;
      }
    }

Этот код похож на предыдущие, но теперь мы вольны отображать блок поиска где
угодно: в боковой панели или на всю ширину. Мы можем использовать в любом
макете, на любом сайте, и ширина браузера не играет никакой роли. Если форме
достаточно места, чтобы расположить поле и кнопку в одну строку, она будет
адаптироваться и показывать их наилучшим образом.

## Ресурсы для начала работы

### Шаблон с подключённым EQCSS

    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf‐8">
      <title></title>
      <style></style>
    </head>
    <body>
    
      <!‐‐[if lt IE 9]><script src="http://elementqueries.com/EQCSS‐polyfills.min.js"></script><![endif]‐‐>
      <script src="http://elementqueries.com/EQCSS.min.js"></script>
    </body>
    </html>

### Демо

*   [Адаптивное соотношение сторон][aspect-ratio]
*   [Заголовок, прилипающий при прокрутке][scroll-header]
*   [Стиль цитат][blockquote-style]
*   [Календарь][calendar]
*   [Блоки содержимого][content-blocks]
*   [Подсчёт дочерних элементов][counting-children]
*   [Дата][date]
*   [Демо в стиле Цастрова][element-query-demo]
*   [Выплывающий блок][flyout]
*   [Адаптивные заголовки][headline]
*   [Медиаплеер][media-player]
*   [Сообщения][message-style]
*   [Диалоговое окно][modal]
*   [Навигация][nav]
*   [Применение стилей к родителю][parent]
*   [Страница расценок][pricing-chart]
*   [Адаптивная таблица][responsive-table]
*   [Блокер при прокрутке][blocker]
*   [Форма регистрации][signup-form]
*   [Блок отзывов][testimonial]
*   [Счётчик символов твита][tweet-counter]
*   [Переменные JS][variables]
*   [Адаптивное масштабирование][video-scaling]
*   [Геометрический дизайн][geometric]
*   [Адаптивная форма заказа][order-form]
*   [Сетка на выражениях для элементов][element-query-grid]
*   [Функции JS в CSS][js-functions-demo]
*   [Адаптивное содержимое][responsive-waterfall]


## Материалы для дальнейшего изучения

Вы сможете найти [проект EQCSS на GitHub][eqcss-gh], [демо][eqcss-demos], документацию и статьи
на [сайте EQCSS][elementqueries]. Всё большее количество [демо на CodePen][eqcss-codepen] использует
EQCSS, и вы можете создать своё собственное, форкнув этот [шаблон][codepen-template], в
котором уже подключён EQCSS. Вы можете [поиграться с утилитой EQCSS][repl],
которая была создана для проверки того, что ваш код EQCSS работает так, как
ожидается.

Приятной разработки!

 [media-queries-are-not-the-answer]: https://www.smashingmagazine.com/2013/06/media-queries-are-not-the-answer-element-query-polyfill "Media Queries Are Not The Answer: Element Query Polyfill"
 [eqcss-logo]: img/eqcss-logo-opt.png "Логотип EQCSS"
 [eqcss-gh]: https://github.com/eqcss/eqcss "EQCSS на GitHub"
 [wicg]: https://discourse.wicg.io/t/element-queries/26 "Тред форума WICG Discourse о выражениях для элементов"
 [mit-license]: https://tldrlegal.com/license/mit-license "Лицензия MIT на TLDR Legal"
 [eqcss]: http://elementqueries.com/EQCSS.js "EQCSS.js"
 [css-has]: https://drafts.csswg.org/selectors-4/#relational "Описание Has в CSS Selectors Level 4"
 [jquery-has]: https://api.jquery.com/has-selector/ "Селектор Has jQuery"
 [caniuse-has]: http://caniuse.com/#feat=css-has "Поддержка Has на caniuse"
 [MeKwaY]: http://codepen.io/tomhodgins/pen/MeKwaY "Демо: Минимальная ширина в пикселях"
 [ezJNpp]: http://codepen.io/tomhodgins/pen/ezJNpp "Демо: Минимальная ширина в процентах"
 [EyPjVg]: http://codepen.io/tomhodgins/pen/EyPjVg "Демо: Максимальная ширина в пикселях"
 [oLbXzG]: http://codepen.io/tomhodgins/pen/oLbXzG "Демо: Максимальная ширина в процентах"
 [PzZqPd]: http://codepen.io/tomhodgins/pen/PzZqPd "Демо: Минимальная высота в пикселях"
 [KMVpdO]: http://codepen.io/tomhodgins/pen/KMVpdO "Демо: Минимальная высота в процентах"
 [EyPjPg]: http://codepen.io/tomhodgins/pen/EyPjPg "Демо: Максимальная высота в пикселях"
 [xOZGZg]: http://codepen.io/tomhodgins/pen/xOZGZg "Демо: Максимальная высота в процентах"
 [vKLOLd]: http://codepen.io/tomhodgins/pen/vKLOLd "Демо: Минимальное количество символов на блочных элементах"
 [OXMVMB]: http://codepen.io/tomhodgins/pen/OXMVMB "Демо: Минимальное количество символов на элементах формы"
 [pbgJyz]: http://codepen.io/tomhodgins/pen/pbgJyz "Демо: Максимальное количество символов на блочных элементах"
 [MeKwyY]: http://codepen.io/tomhodgins/pen/MeKwyY "Демо: Максимальное количество символов на элементах формы"
 [JKGdXN]: http://codepen.io/tomhodgins/pen/JKGdXN "Демо: Минимальное количество строк"
 [oLbXxG]: http://codepen.io/tomhodgins/pen/oLbXxG "Демо: Максимальное количество строк"
 [dXGoMZ]: http://codepen.io/tomhodgins/pen/dXGoMZ "Демо: Минимальное количество дочерних элементов"
 [mEVJPK]: http://codepen.io/tomhodgins/pen/mEVJPK "Демо: Максимальное количество дочерних элементов"
 [OXMVNa]: http://codepen.io/tomhodgins/pen/OXMVNa "Демо: Минимальная прокрутка по Y"
 [beEdpZ]: http://codepen.io/tomhodgins/pen/beEdpZ "Демо: Максимальная прокрутка по Y"
 [ZOQGOb]: http://codepen.io/tomhodgins/pen/ZOQGOb "Демо: Минимальная прокрутка по X"
 [ezJNzJ]: http://codepen.io/tomhodgins/pen/ezJNzJ "Демо: Максимальная прокрутка по X"
 [xOZGOq]: http://codepen.io/tomhodgins/pen/xOZGOq "Демо: Селектор $this"
 [VjeLjy]: http://codepen.io/tomhodgins/pen/VjeLjy "Демо: Селектор $parent"
 [RRrPRy]: http://codepen.io/tomhodgins/pen/RRrPRy "Демо: Селектор $root"
 [gMPpMd]: http://codepen.io/tomhodgins/pen/gMPpMd "Демо: Селектор $prev"
 [PzZqzy]: http://codepen.io/tomhodgins/pen/PzZqzy "Демо: Селектор $next"
 [WxrvxB]: http://codepen.io/tomhodgins/pen/WxrvxB "Демо: Eval"
 [ending-expressions]: https://blogs.msdn.microsoft.com/ie/2008/10/16/ending-expressions/ "Блоги MSDN, конец поддержки выражений"
 [css-specificity]: https://www.smashingmagazine.com/2007/07/css-specificity-things-you-should-know/ "Вещи о специфичности CSS, которые вам следует знать"
 [houdini]: https://www.smashingmagazine.com/2016/03/houdini-maybe-the-most-exciting-development-in-css-youve-never-heard-of/ "Houdini возможно самая удивительная разработка в CSS, о которой вы не слышали"
 [atomic-web-design]: http://bradfrost.com/blog/post/atomic-web-design/ "Атомарный веб-дизайн"
 [aspect-ratio]: http://elementqueries.com/demos/aspect-ratio.html "Адаптивное соотношение сторон"
 [scroll-header]: http://elementqueries.com/demos/scroll-header.html "Заголовок, прилипающий при прокрутке"
 [blockquote-style]: http://elementqueries.com/demos/blockquote-style.html "Стиль цитат"
 [calendar]: http://elementqueries.com/demos/calendar.html "Календарь"
 [content-blocks]: http://elementqueries.com/demos/content-blocks.html "Блоки содержимого"
 [counting-children]: http://elementqueries.com/demos/counting-children.html "Подсчёт дочерних элементов"
 [date]: http://elementqueries.com/demos/date.html "Дата"
 [element-query-demo]: http://elementqueries.com/demos/element-query-demo.html "Демо в стиле Цастрова"
 [flyout]: http://elementqueries.com/demos/flyout.html "Выплывающий блок"
 [headline]: http://elementqueries.com/demos/headline.html "Адаптивные заголовки"
 [media-player]: http://elementqueries.com/demos/media-player.html "Медиаплеер"
 [message-style]: http://elementqueries.com/demos/message-style.html "Сообщения"
 [modal]: http://elementqueries.com/demos/modal.html "Диалоговое окно"
 [nav]: http://elementqueries.com/demos/nav.html "Навигация"
 [parent]: http://elementqueries.com/demos/parent.html "Применение стилей к родителю"
 [pricing-chart]: http://elementqueries.com/demos/pricing-chart.html "Страница расценок"
 [responsive-table]: http://elementqueries.com/demos/responsive-table.html "Адаптивная таблица"
 [blocker]: http://elementqueries.com/demos/blocker.html "Блокер при прокрутке"
 [signup-form]: http://elementqueries.com/demos/signup-form.html "Форма регистрации"
 [testimonial]: http://elementqueries.com/demos/testimonial.html "Блок отзывов"
 [tweet-counter]: http://elementqueries.com/demos/tweet-counter.html "Счётчик символов твита"
 [variables]: http://elementqueries.com/demos/variables.html "Переменные JS"
 [video-scaling]: http://elementqueries.com/demos/video-scaling.html "Адаптивное масштабирование"
 [geometric]: http://elementqueries.com/demos/geometric.html "Геометрический дизайн"
 [order-form]: http://elementqueries.com/demos/order-form.html "Адаптивная форма заказа"
 [element-query-grid]: http://elementqueries.com/demos/element-query-grid.html "Сетка на выражениях для элементов"
 [js-functions-demo]: http://elementqueries.com/demos/js-functions-demo.html "Функции JS в CSS"
 [responsive-waterfall]: http://elementqueries.com/demos/responsive-waterfall.html "Адаптивное содержимое"
 [eqcss-demos]: https://github.com/eqcss/eqcss#element-query-demos "Список демо"
 [elementqueries]: http://elementqueries.com "element queries dot com"
 [eqcss-codepen]: http://codepen.io/search/pens/?q=eqcss&limit=all&order=newest&depth=everything&show_forks=true "Демо на Codepen с использованием EQCSS"
 [codepen-template]: http://codepen.io/pen?template=gagyrz "Шаблон EQCSS: Батарейки прилагаются!"
 [repl]: http://elementqueries.com/repl.html "EQCSS REPL"